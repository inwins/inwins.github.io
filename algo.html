<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>algo</title>
<!-- 2018-03-12 一 00:26 -->
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="bochs" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center; }
  .todo   { font-family: monospace; color: red; }
  .done   { color: green; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  pre.src-sh:before    { content: 'sh'; }
  pre.src-bash:before  { content: 'sh'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-R:before     { content: 'R'; }
  pre.src-perl:before  { content: 'Perl'; }
  pre.src-java:before  { content: 'Java'; }
  pre.src-sql:before   { content: 'SQL'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.right  { text-align: center;  }
  th.left   { text-align: center;   }
  th.center { text-align: center; }
  td.right  { text-align: right;  }
  td.left   { text-align: left;   }
  td.center { text-align: center; }
  dt { font-weight: bold; }
  .footpara:nth-child(2) { display: inline; }
  .footpara { display: block; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  /*]]>*/-->
</style>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">algo</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1. 算法导论</a>
<ul>
<li><a href="#sec-1-1">1.1. 算法入门</a>
<ul>
<li><a href="#sec-1-1-1">1.1.1. 插入排序</a></li>
<li><a href="#sec-1-1-2">1.1.2. 算法分析</a></li>
</ul>
</li>
<li><a href="#sec-1-2">1.2. 函数的增长</a>
<ul>
<li><a href="#sec-1-2-1">1.2.1. 渐进符号</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> 算法导论</h2>
<div class="outline-text-2" id="text-1">
</div><div id="outline-container-sec-1-1" class="outline-3">
<h3 id="sec-1-1"><span class="section-number-3">1.1</span> 算法入门</h3>
<div class="outline-text-3" id="text-1-1">
</div><div id="outline-container-sec-1-1-1" class="outline-4">
<h4 id="sec-1-1-1"><span class="section-number-4">1.1.1</span> 插入排序</h4>
<div class="outline-text-4" id="text-1-1-1">
<p>
把数据分为两个部分，左边一个数据为有序数据范围是[0-i-1],右边是无序数据，范围是【i,n]，令j=i-1，从j开始数据进行比较，比j+1大就赋值给j+1，否则跳出，将i插入到j+1的位置（j最小值为0,但j最后的一次可能为-1）。
</p>
<pre class="example">
#include &lt;stdio.h&gt;
int insert_sort(int *a,int count)
{
  int i,j,key;
  for(i=1;i&lt;count;i++)
  {
   key=a[i];
   for(j=i-1;j&gt;=0;j--)
   {
     if(a[j]&gt;key)
       a[j+1]=a[j];
     else
       break;
   }
   a[j+1]=key;
  }
  return 0;
}
int main()
{
  int i,a[]={1,3,6,2,4,7,9};
  insert_sort(a,sizeof(a)/sizeof(int));
  for(i=0;i&lt;sizeof(a)/sizeof(int);i++)
   printf(" %d",a[i]);
  return 0;
}
</pre>
</div>
<ol class="org-ol"><li><a id="sec-1-1-1-1" name="sec-1-1-1-1"></a>递归迭代与递归<br  /><div class="outline-text-5" id="text-1-1-1-1">
<p>
递归和迭代都是重复调用的表述，都是循环的一种。
递归是函数重复调用函数自身，最终达到结束条件，将所有的小问题结果逐步合并为问题结果。
迭代是上一次循环的结果作为下一次循环的变量的一种循环。
</p>
</div>
</li>
<li><a id="sec-1-1-1-2" name="sec-1-1-1-2"></a>循环不变式<br  /><div class="outline-text-5" id="text-1-1-1-2">
<p>
循环不变式是将一个循环迭代的过程分解为3步，用来证明算法的正确性
初始化，第一次开始迭代的时候是正确的
保持：开始迭代的时候正确，迭代结束的时候也正确
终止：循环结束时，不变式给了我们一个性质，有助于保证算法是正确的。
不变式的前两步的结果是保证循环的正确性，后面的一个性质证明算法的正确性。
</p>
</div>
</li></ol>
</div>
<div id="outline-container-sec-1-1-2" class="outline-4">
<h4 id="sec-1-1-2"><span class="section-number-4">1.1.2</span> 算法分析</h4>
<div class="outline-text-4" id="text-1-1-2">
<p>
插入排序采用的方法是增量法，在有序的数组中将数据插入。还有另外一种方法叫做分治法，
</p>
</div>
<ol class="org-ol"><li><a id="sec-1-1-2-1" name="sec-1-1-2-1"></a>分治法<br  /><ol class="org-ol"><li><a id="sec-1-1-2-1-1" name="sec-1-1-2-1-1"></a>递归分解<br  /><div class="outline-text-6" id="text-1-1-2-1-1">
<p>
将问题划分为子问题，子问题和原问题一样只是规模更小，当子问题足够小时就直接求解，将子问题的解合并构成原问题的解
有很多问题可以采用递归的思路解决：这些方法通常采用分治策略，
1分解：将问题分解为同样的小规模问题，
2解决：直到问题足够小就解决掉，
3合并：合并问题的解，就得到原问题的解。
下面是实现的基于递归方法的归并排序函数。
</p>
<pre class="example">
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
int merge_sort(int *a,int count)
{
  int i,j,k,m,tmp;
  int *b=NULL;
//  printf("count=%d ",count);
//  for(i=0;i&lt;count;i++)
//  printf("%d ",a[i]);
//  puts("\n");
  if(count&gt;1)
  {
    i=count/2;
    merge_sort(a,i);
    merge_sort(a+i,count-i);
    b=(int*)malloc(count);
    if(!b)
       exit(1);
    for(j=0,k=0,m=i;j&lt;count;)
    {
//       for(tmp=0;tmp&lt;count;tmp++)
//         printf("a[%d]=%d ",tmp,a[tmp]);
//       puts("\n");
       if(a[k]&lt;=a[m])
       {
           b[j++]=a[k++];
           if(k&gt;=i)
              break;
       }
       else
       {
           b[j++]=a[m++];
           if(m&gt;=count)
              break;
       }
    }
    if(k&gt;=i)
        memcpy(b+j,a+m,(count-m)*4);
    else
        memcpy(b+j,a+k,(i-k)*4);
//    for(tmp=0;tmp&lt;count;tmp++)
//       printf("b[%d]=%d ",tmp,b[tmp]);
//       puts("\n");
    memcpy(a,b,count*4);
    free(b);
  }
  return 0;
}
int main()
{
  int i,a[]={1,3,6,2,4,7,9};
  insert_sort(a,sizeof(a)/sizeof(int));
  for(i=0;i&lt;sizeof(a)/sizeof(int);i++)
   printf(" %d",a[i]);
  return 0;
}
</pre>
<p>
书中合并的代码是独立的，其中合并两个有序串的时间代价是O(n),其中n是需要合并的元素个数，因为n个元素最多需要n次比较。
</p>
</div>
</li></ol>
</li>
<li><a id="sec-1-1-2-2" name="sec-1-1-2-2"></a>分治法分析<br  /><div class="outline-text-5" id="text-1-1-2-2">
<p>
递归算法的时间复杂度可以写成一个递归的式子。将归并排序的算法一步步的展开为一棵树，树高lgn，每一层时间为cn，总的时间复杂度为O(nlgn)
</p>
</div>
</li></ol>
</div>
</div>
<div id="outline-container-sec-1-2" class="outline-3">
<h3 id="sec-1-2"><span class="section-number-3">1.2</span> 函数的增长</h3>
<div class="outline-text-3" id="text-1-2">
<p>
对于不是很小的输入规模的问题，我们一般关注问题的渐进效率，也就是关心算法运行时间是怎样随输入规模的增长而增长的。
</p>
</div>
<div id="outline-container-sec-1-2-1" class="outline-4">
<h4 id="sec-1-2-1"><span class="section-number-4">1.2.1</span> 渐进符号</h4>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: bochs</p>
<p class="date">Created: 2018-03-12 一 00:26</p>
<p class="creator"><a href="http://www.gnu.org/software/emacs/">Emacs</a> 24.5.1 (<a href="http://orgmode.org">Org</a> mode 8.2.10)</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
