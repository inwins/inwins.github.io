#+AUTHOR:
* pdf电子书籍搜索办法
Library Genesis2M  
数据结构与算法&pdf -(site:wenku.baidu.com) -(site:csdn.net)

site:www.uzzf.com  带书签&书籍名
site:vdisk.weibo.com 
site:pan.baidu.com  
site:dbank.vmall.com
site:u.115.com

* 算法导论
** 算法入门
*** 插入排序
把数据分为两个部分，左边一个数据为有序数据范围是[0-i-1],右边是无序数据，范围是【i,n]，令j=i-1，从j开始数据进行比较，比j+1大就赋值给j+1，否则跳出，将i插入到j+1的位置（j最小值为0,但j最后的一次可能为-1）。
#+BEGIN_SRC 
#include <stdio.h>
int insert_sort(int *a,int count)
{
  int i,j,key;
  for(i=1;i<count;i++)
  {
   key=a[i];
   for(j=i-1;j>=0;j--)
   {
     if(a[j]>key)
       a[j+1]=a[j];
     else
       break;
   }
   a[j+1]=key;
  }
  return 0;
}
int main()
{
  int i,a[]={1,3,6,2,4,7,9};
  insert_sort(a,sizeof(a)/sizeof(int));
  for(i=0;i<sizeof(a)/sizeof(int);i++)
   printf(" %d",a[i]);
  return 0;
}


#+END_SRC
**** 递归迭代与递归
递归和迭代都是重复调用的表述，都是循环的一种。
递归是函数重复调用函数自身，最终达到结束条件，将所有的小问题结果逐步合并为问题结果。
迭代是上一次循环的结果作为下一次循环的变量的一种循环。
**** 循环不变式
循环不变式是将一个循环迭代的过程分解为3步，用来证明算法的正确性
初始化，第一次开始迭代的时候是正确的
保持：开始迭代的时候正确，迭代结束的时候也正确
终止：循环结束时，不变式给了我们一个性质，有助于保证算法是正确的。
不变式的前两步的结果是保证循环的正确性，后面的一个性质证明算法的正确性。
*** 算法分析
插入排序采用的方法是增量法，在有序的数组中将数据插入。还有另外一种方法叫做分治法，
**** 分治法
***** 递归分解
将问题划分为子问题，子问题和原问题一样只是规模更小，当子问题足够小时就直接求解，将子问题的解合并构成原问题的解
有很多问题可以采用递归的思路解决：这些方法通常采用分治策略，
1分解：将问题分解为同样的小规模问题，
2解决：直到问题足够小就解决掉，
3合并：合并问题的解，就得到原问题的解。
下面是实现的基于递归方法的归并排序函数。
#+BEGIN_SRC 
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
int merge_sort(int *a,int count)
{
  int i,j,k,m,tmp;
  int *b=NULL;
//  printf("count=%d ",count);
//  for(i=0;i<count;i++)
//  printf("%d ",a[i]);
//  puts("\n");
  if(count>1)
  {
    i=count/2;
    merge_sort(a,i);
    merge_sort(a+i,count-i);
    b=(int*)malloc(count);
    if(!b)
       exit(1);
    for(j=0,k=0,m=i;j<count;)
    {
//       for(tmp=0;tmp<count;tmp++)
//         printf("a[%d]=%d ",tmp,a[tmp]);
//       puts("\n");
       if(a[k]<=a[m])
       {
           b[j++]=a[k++];
           if(k>=i)
              break;
       }
       else
       {
           b[j++]=a[m++];
           if(m>=count)
              break;
       }
    }
    if(k>=i)
        memcpy(b+j,a+m,(count-m)*4);
    else
        memcpy(b+j,a+k,(i-k)*4);
//    for(tmp=0;tmp<count;tmp++)
//       printf("b[%d]=%d ",tmp,b[tmp]);
//       puts("\n");
    memcpy(a,b,count*4);
    free(b);
  }
  return 0;
}
int main()
{
  int i,a[]={1,3,6,2,4,7,9};
  insert_sort(a,sizeof(a)/sizeof(int));
  for(i=0;i<sizeof(a)/sizeof(int);i++)
   printf(" %d",a[i]);
  return 0;
}
#+END_SRC
书中合并的代码是独立的，其中合并两个有序串的时间代价是O(n),其中n是需要合并的元素个数，因为n个元素最多需要n次比较。
**** 分治法分析
递归算法的时间复杂度可以写成一个递归的式子。将归并排序的算法一步步的展开为一棵树，树高lgn，每一层时间为cn，总的时间复杂度为O(nlgn)
** 函数的增长
对于不是很小的输入规模的问题，我们一般关注问题的渐进效率，也就是关心算法运行时间是怎样随输入规模的增长而增长的。
*** 渐进符号
**** Θ(g(n))渐进确界
存在两个正常量c1和c2，只要n大于一个指定n0，f(n)在c1*g(n)和c2*g(n)之间。
***** 渐进紧确界
g(n)是f(n)的渐进紧确界。
***** 渐进非负
为什么f(n)是渐进非负，我认为f(n)代表了运行时间，所以f(n)必然大于等于0.
**** 大O记法 O(g(n)) 渐进上界
最坏时间
O(g(n))={ f(n): 存在正常数c和n0，使对所有n>=n0，有0<=f(n)<=cg(n) }
**** Ω渐进下界
Ω(g(n))={ f(n): 存在正常数c和n0，使对所有n>=n0，有0<=cg(n)<=f(n) }
**** 非渐进紧确上下界
o(g(n))={ f(n): 对任意正常数c，存在常数n0>0，使对所有的n>=n0，有0<=f(n)<=cg(n) }
ω(g(n))={ f(n): 对任意正常数c，存在常数n0>0，使对所有的n>=n0，有0<=cg(n)<f(n) }
** 分治策略
*** 采用主方法计算程序的复杂度
*** 最大子数组问题
采用分治策略程序实现最大子数组的问题，时间为O(nlogn)
采用迭代法分析解决问题，每一步算法实现依赖前面的结果，分别计算数据扩大一个程序带来变化，并移动游标标注，从而在线性时间内解决问题。
排序算法的最优复杂度为O(nlogn),因为排序导致需要大量数据移动，而有些算法只需要更改游标的位置，不需要移动数据。
*** 矩阵乘法的Strassen算法
这是一种利用中间计算结果减少递归分支的个数，原来的递归分解需要8次二分之一矩阵乘法，利用中间数据后减少了一次，只需要7次二分之一矩阵乘法。
